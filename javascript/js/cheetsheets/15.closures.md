Absolutely! Here's your **JavaScript Closures Cheat Sheet**, crafted specifically for **interview prep** â€” clean, crisp, and packed with clarity for quick last-minute revision.

---

# ğŸ§¾ JavaScript Closures Cheat Sheet

---

## ğŸ”’ What is a Closure?

> A **closure** is created when a function **"remembers"** the variables from its **outer scope**, even after that outer function has finished executing.

âœ… **Function + its lexical environment**
âœ… Enables **data encapsulation**, **private variables**, and **state retention**

---

## ğŸ“¦ Basic Closure Example

```js
function outer() {
  let counter = 0;
  return function inner() {
    counter++;
    console.log(counter);
  };
}

const count = outer();
count(); // 1
count(); // 2 âœ… remembers `counter`
```

âœ… `inner()` is a closure: it **remembers `counter`** even after `outer()` is done

---

## ğŸ§  Why Use Closures?

| Use Case               | Benefit                       |
| ---------------------- | ----------------------------- |
| **Private variables**  | Hide implementation details   |
| **Function factories** | Generate customized functions |
| **Stateful functions** | Retain memory between calls   |
| **Callbacks & async**  | Access outer data in future   |

---

## ğŸ” Private Variables Using Closures

```js
function secret() {
  let password = "1234";
  return {
    getPass: () => password,
    setPass: (newPass) => password = newPass
  };
}

const vault = secret();
vault.getPass();     // "1234"
vault.setPass("abcd");
vault.getPass();     // "abcd"
```

âœ… `password` is **private** â€” only accessible via closure

---

## ğŸ§ª Closure in Loops â€” Classic Gotcha

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// âŒ 3 3 3 (because `var` is function scoped)
```

âœ… Fix using `let` (block-scoped):

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000); // âœ… 0 1 2
}
```

---

## ğŸ—ï¸ Function Factory with Closure

```js
function makeMultiplier(x) {
  return function(y) {
    return x * y;
  };
}

const double = makeMultiplier(2);
double(5); // 10 âœ… remembers x = 2
```

---

## ğŸ§¬ Lexical Scope Enables Closures

```js
function outer() {
  let msg = "hello";
  function inner() {
    console.log(msg);
  }
  return inner;
}
const sayHi = outer();
sayHi(); // "hello"
```

âœ… `inner()` has **lexical scope** access to `outer()`'s `msg`

---

## ğŸ§¹ Memory & Closures

* A closure **retains** access to variables even if the outer function returns
* But the engine **cleans up** unused closures via garbage collection

---

## ğŸ§ª Closure Interview Traps

### âŒ Incorrect

```js
var funcs = [];
for (var i = 0; i < 3; i++) {
  funcs.push(function() {
    return i;
  });
}
funcs[0](); // 3 âŒ (not 0)
```

### âœ… Correct Using Closure

```js
for (var i = 0; i < 3; i++) {
  (function(j) {
    funcs.push(function() {
      return j;
    });
  })(i);
}
funcs[0](); // 0 âœ…
```

---

## ğŸ§  Interview Q\&A

âœ… What is a closure in JS?

âœ… Can you create private variables using closures?

âœ… Why does `var` behave differently in loops with async code?

âœ… How do closures relate to lexical scope?

âœ… What's a practical use of a closure?

---

## âœ… Closure Best Practices

* Use closures for **encapsulation** and **modularity**
* Avoid holding closures for too long (can cause memory leaks in DOM-heavy apps)
* Combine with IIFE for immediate execution

---

## ğŸ’¡ Pro Tip

```js
(function() {
  let counter = 0;
  window.increment = function() {
    console.log(++counter);
  };
})();
increment(); // 1
increment(); // 2
```

âœ… This is a closure that exposes just one global function with hidden state