## Difference between module.export and export:

## âœ… **Short Answer:**

> `exports` is just a **shortcut** (alias) to `module.exports`.
> But if you reassign `exports` directly, you break the link.

---

## ðŸ§  Think of It Like This:

```js
// At the start of a file
exports === module.exports  // âœ… true
```

But if you do:

```js
exports = { hello: 'world' };  // âŒ now it's no longer connected to module.exports
```

This change only affects the local `exports`, not the actual exported object (`module.exports`).

---

## ðŸ“Œ Correct Usage

### âœ… Good: Add properties to `exports`

```js
// math.js
exports.add = (a, b) => a + b;
exports.sub = (a, b) => a - b;
```

This is the same as:

```js
module.exports.add = ...
```

---

## âŒ Incorrect Usage

If you try to reassign `exports` completely:

```js
// math.js
exports = {
  add: (a, b) => a + b
};
```

Then in another file:

```js
const math = require('./math');
console.log(math.add); // âŒ undefined
```

Why? Because `exports` was just a copy â€” reassigning it doesnâ€™t change `module.exports`.

---

## âœ… To Export an Entire Object or Function, Use `module.exports`

```js
// math.js
module.exports = {
  add: (a, b) => a + b,
  sub: (a, b) => a - b
};
```

---

## ðŸ§  Interview One-Liner:

> "`exports` is just a shortcut to `module.exports`. You can add properties to `exports`, but if you reassign it directly, it breaks the connection. Use `module.exports` when exporting an entire object or function."