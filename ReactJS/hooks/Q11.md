### âœ… **When Would You Use `useContext` Hook in React?**

You use the `useContext` hook when you need to **access shared/global data** (like theme, user info, language, etc.) **across multiple components** **without prop drilling**.

---

### ğŸ¯ **Main Scenarios to Use `useContext`**

---

### 1ï¸âƒ£ **Avoiding Prop Drilling**

Instead of passing props deeply through multiple components:

ğŸ“Œ **Without Context:**

```jsx
<App user={user}>
  <Header user={user}>
    <Nav user={user} />
  </Header>
</App>
```

ğŸ“Œ **With `useContext`:**

```jsx
// Create context
const UserContext = React.createContext();

// Provide once
<UserContext.Provider value={user}>
  <App />
</UserContext.Provider>

// Consume anywhere
const user = useContext(UserContext);
```

âœ… Cleaner, simpler, and easier to maintain.

---

### 2ï¸âƒ£ **Global State (Auth, Theme, Language)**

When you need app-wide values like:

* âœ… Auth state (`isLoggedIn`, `user`)
* ğŸ¨ Theme (`dark`, `light`)
* ğŸŒ Localization (`en`, `fr`)
* ğŸ›’ Cart / Favorites

ğŸ“Œ **Example: Accessing Auth**

```jsx
const { user, logout } = useContext(AuthContext);
```

---

### 3ï¸âƒ£ **Settings, Config, or Feature Flags**

Pass down read-only app config or feature toggles:

```jsx
const config = useContext(ConfigContext);
if (config.enableBeta) { /* show feature */ }
```

---

### 4ï¸âƒ£ **Communication Between Sibling Components**

Instead of lifting state up and passing via props, use context.

ğŸ“Œ **Example:**

* Form step components share `formData` via context
* Wizard flow manages state in parent and exposes via `useContext`

---

### âš ï¸ **When NOT to Use `useContext` Alone**

`useContext` **only reads context**. It doesnâ€™t manage or update the state. If you need:

* State management logic (update/dispatch)
* Middleware-like control

ğŸ‘‰ Use `useReducer` with `useContext`, or a state library like **Zustand**, **Jotai**, or **Redux Toolkit**.

---

### ğŸ§ª **Interview Tip Summary**

> Use `useContext` when you need to share global state (like auth, theme, settings) across components without prop drilling. It provides a clean, scalable way to access context values inside functional components.